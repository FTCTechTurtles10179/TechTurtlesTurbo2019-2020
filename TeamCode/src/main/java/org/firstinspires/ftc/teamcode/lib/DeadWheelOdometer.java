package org.firstinspires.ftc.teamcode.lib;

import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.hardware.DcMotor;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Position;
import org.firstinspires.ftc.robotcore.external.navigation.Velocity;
import org.firstinspires.ftc.teamcode.lib.util.data.PVector;
import org.firstinspires.ftc.teamcode.lib.util.states.State;

public class DeadWheelOdometer {
    private Configurator config;
    private DcMotor leftOdometer;
    private DcMotor rightOdometer;
    private DcMotor centerOdometer;
    private PVector robotPos;
    private double robotRot;

    //Utility to find how much encoders have changed
    private double oldLeftEncoder = -1;
    private double oldRightEncoder = -1;
    private double oldBackLeftEncoder = -1;

    //Configure these to our wheels and wheelbase, measure in centimeters
    private PVector leftWheelPos = new PVector(-7.0, 4.0);
    private PVector centerWheelPos = new PVector(0.0, -6.0);
    private PVector rightWheelPos = new PVector(7.0, 4.0);
    double wheelRadius = 4.75;
    double strafeEfficiency = 1.0;
    double forwardEfficiency = 1.0;

    //Configure this to our motors
    double ticksToDegrees = 0.79998;

    //If turning is broken, try changing this to -1 or 1
    double turnerThinger = 1.0;

    //If strafing is broken, try changing this to -1 or 1
    double straferThinger = 1.0;

    //Autogenerated values
    double wheelCircumference = wheelRadius * 2.0 * Math.PI;
    double turnCircumference = (rightWheelPos.x - leftWheelPos.x) * Math.PI;
    double centerCircumference = Math.abs(centerWheelPos.y - ((rightWheelPos.y + leftWheelPos.y)/2)) * 2.0 * Math.PI;

    private void odometryLoop() {

        DeadWheelEncoderValues currentEncoderValues = new DeadWheelEncoderValues(config); // Get current encoder values
        Position2D position2D = odometryCalculation(currentEncoderValues);
    }


    public Position2D odometryCalculation(DeadWheelEncoderValues currentEncoderValues) {
        /* The math behind this code: (W for omega)
        If W_n is the rotation change for wheel n, r is the wheel radius, and K is |X of wheel n| + |Y of wheel n|,
        then we can find the robot's velocity V and rotation velocity W_v using

        r * (1/4W_1 + 1/4W_2 + 1/4W_3 + 1/4W_4)                =   V_x
        r * (-1/4W_1 + 1/4W_2 - 1/4W_3 + 1/4W_4)               =   V_y
        r * (-1/(4K)W_1 - 1/(4K)W_2 + 1/(4K)W_3 + 1/(4K)W_4)   =   W_v
        */

        double leftDistChange = ((oldLeftEncoder - currentEncoderValues.left) * ticksToDegrees) * wheelCircumference;
        double rightDistChange = ((oldRightEncoder - currentEncoderValues.right) * ticksToDegrees) * wheelCircumference;
        double centerDistChange = ((oldBackLeftEncoder - currentEncoderValues.center) * ticksToDegrees) * wheelCircumference;

        double localRobotRot = (((leftDistChange - rightDistChange) / 2.0) / turnCircumference) * 360.0 * turnerThinger;

        PVector localRobotPos;
        localRobotPos = new PVector(
                centerDistChange - ((localRobotRot / 360.0) * centerCircumference),
                (leftDistChange + rightDistChange) / 2.0
        );

        if (config.getDebugMode()) config.telemetry.addLine("LocalPos: (" + Math.round(localRobotPos.x) + ", " + Math.round(localRobotPos.y) + ")");
        if (config.getDebugMode()) config.telemetry.addLine("LocalRot: " + Math.round(localRobotRot));

        //Convert to "field" coordinates
        localRobotPos = new PVector(localRobotPos.x * strafeEfficiency, localRobotPos.y * forwardEfficiency);
        PVector rotated = localRobotPos.rotate(Math.toRadians(robotRot));

        //Add how the robot has moved to it's overall position
        setPos(PVector.add(robotPos, rotated));
        double addedRotation = robotRot - Math.toDegrees(localRobotRot);
        double posClippedRotation = addedRotation > 360.0 ? addedRotation - 360.0 : addedRotation;
        double clippedRotation = posClippedRotation < 0.0 ? posClippedRotation + 360.0 : posClippedRotation;
        setRot(clippedRotation);

        //Update all of the "old" values
        oldLeftEncoder = currentEncoderValues.left;
        oldRightEncoder = currentEncoderValues.right;
        oldBackLeftEncoder = currentEncoderValues.center;

        return new Position2D(robotPos,clippedRotation);
    }
    
    public DeadWheelOdometer(Configurator config) { //Store the config
        this.config = config;
    }

    public void beginOdometry() {
        leftOdometer = config.getDcMotor("leftOdometer");
        rightOdometer = config.getDcMotor("rightOdometer");
        centerOdometer = config.getDcMotor("centerOdometer");

        //Update all of the "old" values
        oldLeftEncoder = leftOdometer.getCurrentPosition();
        oldRightEncoder = rightOdometer.getCurrentPosition();
        oldBackLeftEncoder = centerOdometer.getCurrentPosition();

        //Ad a state tu run odometry functions every tick
        State odometryState = new State(() -> {
            //Run both odometry loops
            odometryLoop();

            //Telemetry
            if (config.getDebugMode()) config.telemetry.addLine("Pos: (" + Math.round(robotPos.x) + ", " + Math.round(robotPos.y) + ")");
            if (config.getDebugMode()) config.telemetry.addLine("Rot: " + Math.round(robotRot));
            return false;
        }, () -> {}, "Odometry");

        config.stateMachine.addState(odometryState);
    }

    public PVector getPos() {
        return robotPos;
    }

    public double getRot() {
        return robotRot;
    }

    public void setPos(PVector pos) {
        robotPos = pos;
    }

    public void setRot(double rot) {
        robotRot = rot;
    }


    public static class DeadWheelEncoderValues{
        public double left = 0;
        public double center = 0;
        public double right = 0;

        public DeadWheelEncoderValues() {
        }

        public DeadWheelEncoderValues(double left, double center, double right) {
            this.left = left;
            this.center = center;
            this.right = right;
        }

        // Derive current odometry values directly from configurator/encoder values.
        public DeadWheelEncoderValues(Configurator configurator) {
            DcMotor leftOdometer = configurator.getDcMotor("leftOdometer");
            DcMotor centerOdometer = configurator.getDcMotor("centerOdometer");
            DcMotor rightOdometer = configurator.getDcMotor("rightOdometer");

            this.left = leftOdometer.getCurrentPosition();
            this.center = centerOdometer.getCurrentPosition();
            this.right = rightOdometer.getCurrentPosition();
        }

        public DeadWheelEncoderValues subtractAndReturn(DeadWheelEncoderValues deadWheelEncoderValues) {
            return new DeadWheelEncoderValues(
                    left - deadWheelEncoderValues.left,
                    center - deadWheelEncoderValues.center,
                    right - deadWheelEncoderValues.right);
        }

        public DeadWheelEncoderValues addAndReturn(DeadWheelEncoderValues deadWheelEncoderValues) {
            return new DeadWheelEncoderValues(
                    left + deadWheelEncoderValues.left,
                    center + deadWheelEncoderValues.center,
                    right + deadWheelEncoderValues.right);
        }

        public String toString() {
            String format_command = "%8.1f";
            return String.format(format_command,left) + ",  " + String.format(format_command,center) + ", " + String.format(format_command,right) + "";
        }

        public DeadWheelEncoderValues copy() {
            return new DeadWheelEncoderValues(this.left,this.center,this.right);
        }
    }


    static public class Position2D {
        public PVector position = new PVector(0,0);
        public double theta = 0;

        public Position2D(PVector position, double theta) {
            this.position = position.copy();
            this.theta = theta;
        }

        public Position2D(double x, double y, double theta) {
            this.position = new PVector(x,y);
            this.theta = theta;
        }

        public double getX() {
            return position.x;
        }

        public double getY() {
            return position.y;
        }

        public double getTheta() {
            return theta;
        }

        public String toString() {
            String format_command = "%8.2f";
            return String.format(format_command,position.x) + ",  " + String.format(format_command,position.y) + ", " + String.format(format_command,theta) + "";
        }
    }

}
